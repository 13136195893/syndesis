#!/bin/bash

setup_oc() {

    # Check path first if it already exists
    set +e
    which oc &>/dev/null
    if [ $? -eq 0 ]; then
      set -e
      return
    fi

    # Check for minishift
    which minishift &>/dev/null
    if [ $? -eq 0 ]; then
      set -e
      eval $(minishift oc-env)
      return
    fi

    set -e

    # Error, no oc found
    echo "ERROR: No 'oc' binary found in path. Please install the client tools from https://github.com/openshift/origin/releases/tag/v3.7.0 (or newer)"
    exit 1
}

recreate_project() {
    local project=$1
    local dont_ask=${2:-false}

    if [ -z "$project" ]; then
        echo "No project given"
        exit 1
    fi

    # Delete project if existing
    if oc get project "${project}" >/dev/null 2>&1 ; then
        if [ $dont_ask != "true" ]; then
            echo =============== WARNING -- Going to delete project ${project}
            oc get all -n $project
            echo ============================================================
            read -p "Do you really want to delete the existing project $project ? yes/[no] : " choice
            echo
            if [ "$choice" != "yes" ] && [ "$choice" != "y" ]; then
                echo "Aborting on user's request"
                exit 1
            fi
        fi
        echo "Deleting project ${project}"
        oc delete project "${project}"
    fi

    # Create project afresh
    echo "Creating project ${project}"
    for i in {1..10}; do
        if oc new-project "${project}" >/dev/null 2>&1 ; then
            break
        fi
        echo "Project still exists. Sleeping 10s ..."
        sleep 10
    done
    oc project "${project}"
}

select_template() {
    local is_dev=${1:-false}
    if [ ${is_dev} == "true" ]; then
        echo "syndesis-dev"
    else
        echo "syndesis"
    fi
}

create_oauthclient() {
    local tag=${1:-master}
    local use_local_resource=${2:-}

    create_openshift_resource \
        "install/support/serviceaccount-as-oauthclient-restricted.yml" \
        "$tag" \
        "$use_local_resource"
}

create_and_apply_template() {
    local route=$1
    local template=${2:-syndesis}
    local tag="$(readopt --tag)"
    local use_local_resource="$(hasflag --local)"
    local test_support="$(hasflag --test-support)"

    if [ -z "$route" ]; then
        echo "No route given"
        exit 1
    fi

    create_openshift_resource \
        "install/${template}.yml" \
        "$tag" \
        "$use_local_resource"

    local template_name=$(get_template_name $template $tag)
    # Use '-restricted' template for tag <= 1.2
    if [ -n "$tag" ] && [[ $tag =~ 1\.[12] ]]; then
        template_name="${template_name}-restricted"
    fi

    local optional_args=""
    if [ -n "$(readopt --memory-server)" ]; then
      optional_args="$optional_args -p SERVER_MEMORY_LIMIT=$(readopt --memory-server)"
    fi
    if [ -n "$(readopt --memory-meta)" ]; then
      optional_args="$optional_args -p META_MEMORY_LIMIT=$(readopt --memory-meta)"
    fi
    if [ $(hasflag --test-support) ]; then
      optional_args="$optional_args -p TEST_SUPPORT_ENABLED=true"
    fi

    oc new-app --template=${template_name} \
      -p ROUTE_HOSTNAME="${route}" \
      -p OPENSHIFT_MASTER="$(oc whoami --show-server)" \
      -p OPENSHIFT_PROJECT="$(oc project -q)" \
      -p OPENSHIFT_OAUTH_CLIENT_SECRET=$(oc sa get-token syndesis-oauth-client) \
      $optional_args
}

# Try first a template with the tag as combination
get_template_name() {
    local template=$1
    local tag=${2:-}
    if [ -n "$tag" ]; then
        local candidate="$template-$tag"
        $(oc get template $candidate >/dev/null 2>&1)
        if [ $? -eq 0 ]; then
          echo $candidate
          return
        fi
    fi


    echo $template
}

create_openshift_resource() {
    local resource=${1:-}
    local tag=${2:-}
    local use_local_resource=${3:-}


    # Adapt to old names if tag is smaller than 1.3. Remove this when going to
    # GA
    if [ -n "$tag" ]; then
        if [[ $tag =~ 1\.[12] ]] && [[ ! $resource =~ restricted ]]; then
          local base=$(basename $resource .yml)
          local dir=$(dirname $resource)
          resource="$dir/../app/deploy/${base}-restricted.yml"
        fi
    fi

    if [ -n "$use_local_resource" ]; then
        if [ -n "$tag" ]; then
            pushd $(appdir) >/dev/null
            git fetch --tags
            git show $tag:${resource} | oc create -f -
            popd >/dev/null
        else
            oc create -f $(appdir)/../$resource
        fi
    else
        oc create -f https://raw.githubusercontent.com/syndesisio/syndesis/${tag:-master}/${resource}
    fi
}

wait_for_syndesis_to_be_ready() {
    # Wait a bit to start image fetching
    # Patch imagestreams from "DockerImage" to "ImageStreamTag"
    oc get pods -w &
    watch_pid=$!
    for dc in "syndesis-server" "syndesis-ui" "syndesis-meta"; do
        echo "Waiting for $dc to be started"
        local replicas="$(oc get dc $dc -o jsonpath='{.status.availableReplicas}')"
        while [ "$replicas" -lt 1 ]; do
            echo "Sleeping 10s ..."
            sleep 10
            replicas=$(oc get dc $dc -o jsonpath="{.status.availableReplicas}")
        done
    done
    kill $watch_pid
}

patch_imagestreams_for_initial_image() {
    for is in "syndesis-server" "syndesis-ui" "syndesis-meta" "syndesis-s2i"; do
        echo "Patching imagestream $is"
        local replace_kind='{"op": "replace", "path": "/spec/tags/0/from/kind", "value": "ImageStreamTag"}'
        local replace_name="{\"op\": \"replace\", \"path\": \"/spec/tags/0/from/name\", \"value\": \"$is:latest\"}"
        local remove_import_policy='{"op": "remove", "path": "/spec/tags/0/importPolicy"}'
        oc patch is $is --type json -p="[$replace_kind, $replace_name, $remove_import_policy]"
    done
}

guess_route() {
    local project=${1:-}
    if [ -z "${project}" ]; then
        project=$(oc project -q)
    fi
    local log=$(oc create service clusterip smokeservice --tcp=4343 2>&1 && \
                oc create route edge --service=smokeservice 2>&1)
    if [ $? != 0 ]; then
        echo "ERROR: Cannot create pivot route\n$log"
        exit 1
    fi
    local domain=$(oc get route smokeservice -o template  --template='{{.spec.host}}' 2>&1)
    if [ $? != 0 ]; then
        echo "ERROR: Cannot extract route: $domain"
        exit 1
    fi
    log=$(oc delete service smokeservice 2>&1 && \
          oc delete route smokeservice 2>&1)
    if [ $? != 0 ]; then
        echo "ERROR: Cannot delete pivot route\n$log"
        exit 1
    fi
    echo "${project}.${domain#*.}"
}

create_api_cookie() {

    local COOKIE1="$HOME/syndesis_cookie.txt"
    # second cookie needed because curl flushes old values upon redirect. Might be a bug or some obscure flag missing
    local COOKIE2="$(mktemp /tmp/syndesis_cookie.XXX.txt)"
    # generate a new user so that it will be asked to approve permissions delegation
    local USERNAME="dev$RANDOM"

    # clean cookie
    rm -rf "$COOKIE1"
    touch "$COOKIE1"

    local SYNDESIS_URL="$(oc get route syndesis  --template={{.spec.host}})"
    # first invocation is needed just to get the redierect url and to define a csrf token
    local REDIRECTED_URL="$(curl --write-out "%{url_effective}\n" --location --silent --show-error --output /dev/null --insecure --cookie-jar  "$COOKIE1" -v "https://$SYNDESIS_URL" 2>/dev/null )"

    # isolate required params
    local LOGIN_URL="$(echo $REDIRECTED_URL | sed -e 's/?/\n/g' | head -n1)"
    local THEN_URL="$(echo $REDIRECTED_URL | sed -e 's/=/\n/g' | tail -n1)"
    local CSRF=$(cat "$COOKIE1"  | grep -Po '(?<=\scsrf).*' | awk '{$1=$1;print}')

    # login on OpenShift and save output to TEMP_STATE location
    local TEMP_STATE="$(mktemp /tmp/syndesis_state.XXX.html)"
    curl --referer "$REDIRECTED_URL" --insecure --location  -H "Cookie: csrf=$CSRF" --data-urlencode username="$USERNAME"  --data-urlencode password="developer" --data-ascii then="$THEN_URL" --data-urlencode csrf="$CSRF" --cookie-jar "$COOKIE2" -i -v -o "$TEMP_STATE" "https://$(minishift ip):8443/login"  2>/dev/null

    # move the freshly created "ssn" cookie entry back to the main cookie
    tail -1 "$COOKIE2" >> "$COOKIE1"

    # extract state token
    local STATE=$(grep  -E '"then' $TEMP_STATE | grep -o -E 'state=.*%3' | sed 's#state=##' | sed 's#%3##')

    # approve permission delegation, weaving all the params in the GET parameters
    curl --insecure --location --cookie-jar "$COOKIE1" --cookie "$COOKIE1" -i -v --data "then=..%2Fauthorize%3Fapproval_prompt%3Dforce%26client_id%3Dsystem%253Aserviceaccount%253Amyproject%253Asyndesis-oauth-client%26redirect_uri%3Dhttps%253A%252F%252F$SYNDESIS_URL%252Foauth%252Fcallback%26response_type%3Dcode%26scope%3Duser%253Ainfo%2Buser%253Acheck-access%26state%3D$STATE%253A%252F&csrf=$CSRF&client_id=system%3Aserviceaccount%3Amyproject%3Asyndesis-oauth-client&user_name=$USERNAME&redirect_uri=https%3A%2F%2F$SYNDESIS_URL%2Foauth%2Fcallback&scope=user%3Ainfo&scope=user%3Acheck-access&approve=Allow+selected+permissions"  -H 'dnt: 1' -H "referer: https://$(minishift ip):8443/oauth/authorize/approve?client_id=system%3Aserviceaccount%3Amyproject%3Asyndesis-oauth-client&redirect_uri=https%3A%2F%2F$SYNDESIS_URL%2Foauth%2Fcallback&scope=user%3Ainfo+user%3Acheck-access&then=..%2Fauthorize%3Fapproval_prompt%3Dforce%26client_id%3Dsystem%253Aserviceaccount%253Amyproject%253Asyndesis-oauth-client%26redirect_uri%3Dhttps%253A%252F%252F$SYNDESIS_URL%252Foauth%252Fcallback%26response_type%3Dcode%26scope%3Duser%253Ainfo%2Buser%253Acheck-access%26state%3D$STATE%253A%252F" "https://$(minishift ip):8443/oauth/authorize/approve" -o /dev/null 2>/dev/null

    # smoke test showing how to use the cookie
    echo "Cookie created at $COOKIE1"
    echo Sample invocation: curl -k --cookie "$COOKIE1" "https://$(oc get route syndesis --template={{.spec.host}})/api/v1/connections"
}