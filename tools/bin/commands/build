#!/bin/bash


build::description() {
    echo "Run Syndesis builds"
}

build::usage() {
    cat <<EOT
-b  --backend                 Build only backend modules (core, extension, integration, connectors, server, meta)
    --all-images              Build only modules with Docker images (ui, server, meta, s2i) and create images
-m  --module <m1>,<m2>, ..    Build modules
                              Modules: ui, server, connector, s2i, meta, integration, extension, common
-d  --dependencies            Build also all project the specified module depends on
    --skip-tests              Skip unit and system test execution
    --skip-checks             Disable all checks
-f  --flash                   Skip checks and tests execution (fastest mode)
-i  --image                   Build Docker via s2i images, too
    --docker                  Use a plain Docker build for creating images. Used by CI for pushing to Docker Hub
-p  --project <project>       Specifies the project to create images in when using '--openshift'
-e  --ensure                  If building a Go module, run 'dep ensure' before building
-l  --local                   For Go builds: Use a locally installed go, otherwise run the Go build from a container
-c  --clean                   Run clean builds (mvn clean)
    --batch-mode              Run mvn in batch mode
    --camel-snapshot          Run a build with a specific Camel snapshot. You'll need to set an environment variable CAMEL_SNAPSHOT_VERSION with the SNAPSHOT version you want to use.
EOT

}

build::run() {
    # Maven helper funcs
    source "$(basedir)/commands/util/maven_funcs"

    # For building the operator
    source "$(basedir)/commands/util/operator_funcs"

    # For OpenShift based builds
    source "$(basedir)/commands/util/openshift_funcs"

    local modules="$(extract_modules)"

    local top_dir="$(appdir .)"

    # All Maven modules (all modules minus operator)
    local maven_modules=$(filter_module "operator" "$modules")
    if [ -z "$modules" ] || [ -n "$maven_modules" ]; then
        call_maven "$(maven_args)" "$maven_modules"
    fi

    # Build operator if required
    if $(should_build "operator" "$modules"); then
        operator $top_dir
    fi

}

operator() {
    local top_dir=$1
    echo "=============================================================================="
    echo "Building syndesis-operator"
    echo "=============================================================================="

    if [ "$(hasflag -e --ensure)" ]; then
        dep_ensure "$top_dir" "$(hasflag -l --local)"
    fi
    build_operator "$top_dir" "$(hasflag -l --local)" "$(hasflag -i --image --images)"

    if [ "$(hasflag -i --image --images --docker)" ]; then
        create_operator_image "$top_dir" "$(hasflag --docker)"
    fi
}

maven_args() {
    local project=${1:-}
    local args=""

    if [ $(hasflag --flash -f) ]; then
        args="$args -Pflash"
    fi

    if [ $(hasflag --skip-tests) ]; then
        args="$args -DskipTests"
    fi

    if [ $(hasflag --skip-checks) ]; then
        args="$args -Pskip-checks"
    fi

    if [ $(hasflag --batch-mode) ]; then
        args="$args --batch-mode"
    fi

    if [ $(hasflag --image -i --all-images --docker) ]; then
        #Build images
        args="$args -Pimage"
        if [ $(hasflag --docker) ]; then
            args="$args -Dfabric8.mode=kubernetes"
        else
            args="$args -Dfabric8.mode=openshift"
        fi
    fi

    set +o nounset
    if [ $(hasflag --camel-snapshot) ]; then
       if [ -n "$CAMEL_SNAPSHOT_VERSION" ]; then
           args="$args -Dcamel.version=$CAMEL_SNAPSHOT_VERSION"
       else
           echo "ERROR: you need to set the environment variable CAMEL_SNAPSHOT_VERSION to use --camel-snapshot option".
           exit 1
       fi
    fi
    set -o nounset

    if [ -z "$project" ]; then
        project="$(readopt --project -p)"
    fi
    if [ -n "${project}" ]; then
        args="$args -Dfabric8.namespace=${project}"
    fi

    if [ "$(hasflag --clean -c)" ]; then
        args="$args clean"
    fi

    local goals="$(readopt --goals)"
    if [ -n "${goals}" ]; then
        args="$args ${goals//,/ }"
    else
        args="$args install"
    fi

    echo $args
}


# All modules, in the right build order
ALL_MODULES="common extension integration connector meta server s2i ui test operator"
MODULES=(
  "operator"
  "ui"
  "common"
  "extension:common"
  "integration:common extension"
  "connector:common extension integration"
  "meta:common extension integration connector"
  "server:common extension integration connector"
  "s2i:common extension integration connector server"
  "test:common extension integration connector server s2i"
)


extract_modules() {
    local modules=""

    if [ "$(hasflag --backend -b)" ]; then
        modules="$modules common extension integration connector server meta"
    fi

    if [ "$(hasflag --all-images)" ]; then
        modules="$modules ui server meta s2i operator"
    fi

    local arg_modules=$(readopt --module -m);
    if [ -n "${arg_modules}" ]; then
        modules="$modules ${arg_modules//,/ }"
    fi

    if [ "$(hasflag --dependencies -d)" ]; then
        local extra_modules=""
        for module in $modules; do
            for m in "${MODULES[@]}"; do
              local k=${m%%:*}
              if [ "$module" == $k ]; then
                  local v=${m#*:}
                  extra_modules="${extra_modules} $v"
              fi
            done
        done
        modules="$modules $extra_modules"
    fi
    if [ -z "$modules" ]; then
      return
    fi
    # Unique modules
    local unique_modules=$(echo $modules | xargs -n 1 | sort -u | xargs | awk '$1=$1')
    echo $(order_modules "$unique_modules")
}

order_modules() {
    # Fix order
    local modules="$1"
    # All modules in the proper order
    local ret=$ALL_MODULES
    for cm in "${MODULES[@]}"; do
      local check_module=${cm%%:*}
      # Check if $check_module is in the module list
      if [ -n "${modules##*${check_module}*}" ]; then
        # No, so remove it from the return value
        ret=${ret//$check_module/}
      fi
    done

    # Normalize return value
    echo $ret | awk '$1=$1'
}

filter_module() {
    local filter="$1"
    local modules="$2"

    echo ${modules//$filter} | awk '$1=$1'

}

should_build() {
    local module="$1"
    local modules="$2"
    if [ -z "$modules" ]; then
        # Empty --> Build everything
        echo "true"
    elif [ "${modules//$module}" != "${modules}" ]; then
        # Modules contains module
        echo "true"
    else
        echo "false"
    fi
}
