package io.syndesis.maven.annotation.processing;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URI;
import java.util.Properties;
import java.util.Set;

@SuppressWarnings({"PMD.AvoidSynchronizedAtMethodLevel", "PMD.AvoidCatchingGenericException", "PMD.ExcessiveImports"})
@SupportedSourceVersion(value = SourceVersion.RELEASE_8)
@SupportedAnnotationTypes({
    SyndesisExtensionActionProcessor.ANNOTATION_NAME
})
public class SyndesisExtensionActionProcessor extends AbstractProcessor {
    public static final String ANNOTATION_NAME = "io.syndesis.integration.runtime.api.SyndesisExtensionAction";
    public Class<? extends Annotation> annotationClass ;

	@Override
	public synchronized void init(ProcessingEnvironment env){
        this.processingEnv = env;
        try {
            annotationClass = (Class<? extends Annotation>) Class.forName(ANNOTATION_NAME);
        } catch (ClassNotFoundException e) {
            error("Unable to find Annotation " +  ANNOTATION_NAME + " on Classpath");
        }
    }

	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
	    // a lot of noisy logic to prevent this method to ever fail, since it's required by the compiler implicit contract
	    if(annotationClass == null){
            return false;
        }
        for (Element annotatedElement : env.getElementsAnnotatedWith(annotationClass)) {
            if (annotatedElement.getKind() != ElementKind.CLASS) {
                return true; // Exit processing
            }
            try {
                TypeElement typedElement = (TypeElement) annotatedElement;
                Properties props = gatherProperties(typedElement);
                augmentProperties(typedElement, props);
                persistToFile(typedElement, props);
            } catch (Exception e){
                return false;
            }
        }
	    return false;
    }

    /**
     * Explicitly add properties that elude reflection implicit strategy
     * @param typedElement
     * @param props
     */
    protected void augmentProperties(TypeElement typedElement, Properties props) {
        props.put("kind", typedElement.getQualifiedName().toString());
    }

    protected Properties gatherProperties(TypeElement classElement) throws InvocationTargetException, IllegalAccessException {
        Properties prop = new Properties();
        Annotation annotation = classElement.getAnnotation(annotationClass);
        Method[] methods = annotationClass.getDeclaredMethods();
        for (Method m : methods) {
            writeIfNotEmpty(prop, m.getName(), m.invoke(annotation));
        }
        return prop;
    }

    protected void persistToFile(TypeElement classElement, Properties props) throws IOException {
        File file = obtainResourceFile(classElement);
        try(Writer writer = new FileWriter(file)) {
            props.store(writer, "Generated by Syndesis Annotation Processor");
        }
    }


    protected void writeIfNotEmpty(Properties prop, String key, Object value) {
	    if(value != null && !"".equals(value.toString().trim())){
	        if(value instanceof String[]){
	            String[] arr = (String[])value;
	            if(arr.length > 0){
	                prop.put(key, String.join(",", arr));
                }
            } else {
                prop.put(key, value);
            }
        }
    }

    /**
     * Returns the canonical class name by removing any generic type information.
     */
    public static String canonicalClassName(String className) {
        // remove generics
        int pos = className.indexOf('<');
        if (pos != -1) {
            return className.substring(0, pos);
        } else {
            return className;
        }
    }


    /**
     * Helper method to produce class output text file using the given handler
     */
    protected File obtainResourceFile(TypeElement classElement) throws IOException {
        File result = null;
        Filer filer = processingEnv.getFiler();

        final String javaTypeName = canonicalClassName(classElement.getQualifiedName().toString());
        String packageName = javaTypeName.substring(0, javaTypeName.lastIndexOf('.'));
        String fileName = classElement.getSimpleName().toString() + ".properties";

        FileObject resource;
        try {
            resource = filer.getResource(StandardLocation.SOURCE_OUTPUT, packageName, fileName);
        } catch (Exception e) {
            resource = filer.createResource(StandardLocation.SOURCE_OUTPUT, packageName, fileName);
        }
        URI uri = resource.toUri();
        if (uri != null) {
            try {
                result = new File(uri.getPath());
            } catch (Exception e) {
                warning("Cannot convert output directory resource URI to a file " + e);
            }
        }
        if (result == null) {
            warning("No class output directory could be found!");
        } else {
            result.getParentFile().mkdirs();
        }
        return result;
    }

    public void info(String message) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
    }

    public void warning(String message) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, message);
    }

    public void error(String message) {
        processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
    }

}
