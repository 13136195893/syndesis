[id='develop-step-extensions']
= Alternatives for developing step extensions 

Syndesis supports different ways to provide custom steps:

- Using Camel routes created with xml fragments
- Using Camel routes created with RouteBuilder
- Using Camel beans
- Using Syndesis Step API


[NOTE]
====
Syndesis provide a set of custom java annotation that used in conjunction with the syndesis-extension-pluing can automatically add actions definitions in the extension descriptor for extension coded using Java. To enable annotation processing it is required to add the following dependency to your maven project:

[source,xml]
----
<dependency>
  <groupId>io.syndesis.extension</groupId>
  <artifactId>extension-annotation-processor</artifactId>
  <optional>true</optional>
</dependency>
----
====

== Using xml route fragments

An action developed as xml fragment is just a Caml route with an input such as `direct` which is invoked by the Syndesis runtime like any other route.

As example, you may want to create a step that logs the body of a message with an optional prefix, this can be done with a route fragment like:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<routes xmlns="http://camel.apache.org/schema/spring"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://camel.apache.org/schema/spring
      http://camel.apache.org/schema/spring/camel-spring.xsd">

  <route id="log-body-with-prefix">
    <from uri="direct:log"/>
    <choice>
      <when>
        <simple>${header.prefix} != ''</simple>
        <log message="${header.prefix} ${body}"/>
      </when>
      <otherwise>
        <log message="Output ${body}"/>
      </otherwise>
    </choice>
  </route>

</routes>
----

As we do not _yet_ have a way to automatically generate the related action defintion, you'd need to create a descriptor template `src/main/resources/META-INF/syndesis/syndesis-extension-definition.json` with the following content:

[source,json]
----
{
  "actionType": "step",
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <1>
    "entrypoint": "direct:log", <2>
    "resource": "classpath:log-body-action.xml", <3>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
  "propertyDefinitionSteps": [ {
    "description": "extension-properties",
    "name": "extension-properties",
    "properties": { <4>
      "prefix": {
        "componentProperty": false,
        "deprecated": false,
        "description": "The Log body prefix message",
        "displayName": "Log Prefix",
        "javaType": "String",
        "kind": "parameter",
        "required": false,
        "secret": false,
        "type": "string"
      }
    }
  } ]
  }
}
----
<1> the type of action is set to `ENDPOINT` as the runtime should invoke a Camel endpoint to execute this action/step
<2> the Camel endpoint to invoke which is the `from` of our route
<3> the location of the xml fragment
<4> the propertis this step/action exposes to the user, each value set by the user is set to a message header with the same name as the property

[WARNING]
====
Syndesis does not support full Camel XML configuration but only the <routes> tag.
====

== Using RouteBuilder

An action developed as route with the support of RouteBuilder is just a Camel route with an input such as `direct` which is invoked by the Syndesis runtime like any other route.

To implement the same example as the one used to show how to use xml fragments, you can write something like:

[source,java]
----
import org.apache.camel.builder.RouteBuilder;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action( // <1>
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix",
    entrypoint = "direct:log")
public class LogAction extends RouteBuilder {
    @ConfigurationProperty( // <2>
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Override
    public void configure() throws Exception {
        from("direct::start") // <3>
            .choice()
                .when(simple("${header.prefix} != ''"))
                    .log("${header.prefix} ${body}")
                .otherwise()
                    .log("Output ${body}")
            .endChoice();
    }
}
----
<1> the action definition
<2> the property definition
<3> the action implementation

As we are using java and Syndesis annotations we can leverage the extension-maven-plugin to automatically generate the action definition which will look like:

[source,json]
----
{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "ENDPOINT", <1>
    "entrypoint": "direct:log", <2>
    "resource": "class:io.syndesis.extension.log.LogAction", <3>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": { <4>
        "prefix": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}
----
<1> the type of action is set to `ENDPOINT` as the runtime should invoke a Camel endpoint to execute this action/step
<2> the Camel endpoint to invoke which is the `from` of our route
<3> the class that implements `RoutesBuilder`
<4> the properties this step/action exposes to the user, each value set by the user is set to a message header with the same name as the property

=== Using beans

An action developed as bean is just a Camel bean processor.

To implement the same example as the one used to show how to use xml fragments, you can write something like:

[source,java]
----
import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.apache.camel.Header;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    @Handler // <1>
    public void process(@Header("prefix") String prefix, @Body Object body) {
        if (prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", prefix, body);
        }
    }
}
----
<1> the function that implement the action.

As we are using java and Syndesis annotations we can leverage the extension-maven-plugin to automatically generate the action definition which will look like:

[source,json]
----
{
  "id": "log-body-with-prefix",
  "name": "Log body with prefix",
  "description": "A simple body log with a prefix",
  "descriptor": {
    "kind": "BEAN", <1>
    "entrypoint": "io.syndesis.extension.log.LogAction::process", <2>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "prefix": { <3>
          "componentProperty": false,
          "deprecated": false,
          "description": "The Log body prefix message",
          "displayName": "Log Prefix",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "actionType": "step"
}
----
<1> the type of action is set to `BEAN` as the runtime should invoke a Camel bean processor to execute this action/step
<2> the Camel bean to invoke
<3> the properties this step/action exposes to the user, each value set by the user is set to a message header with the same name as the property

As we are using beans we can also decide to inject user properties to the bean instead of retrieving it from the exchange header by implementing getters and setters for the properties we want to get injected. Our action implementation would look like:

[source,java]
----
import org.apache.camel.Body;
import org.apache.camel.Handler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;

@Action(
    id = "log-body-with-prefix",
    name = "Log body with prefix",
    description = "A simple body log with a prefix")
public class LogAction  {
    private static final Logger LOGGER = LoggerFactory.getLogger(LogAction.class);

    @ConfigurationProperty(
        name = "prefix",
        description = "The Log body prefix message",
        displayName = "Log Prefix",
        type = "string")
    private String prefix;

    public void setPrefix(String prefix) { // <1>
        this.prefix = prefix;
    }

    public String getPrefix() { // <2>
        return prefix;
    }

    @Handler
    public void process(@Body Object body) {
        if (this.prefix == null) {
            LOGGER.info("Output {}", body);
        } else {
            LOGGER.info("{} {}", this.prefix, body);
        }
    }
}
----
<1> property setter
<2> property getter

== Using Step API

An action developed using Step API give developers a way to interact with the runtime route creation so developers can use any method provided by a `ProcessorDefinition` and can create more complex routes such as a slit step:

[source,java]
----
import java.util.Map;
import java.util.Optional;

import io.syndesis.extension.api.Step;
import io.syndesis.extension.api.annotations.Action;
import io.syndesis.extension.api.annotations.ConfigurationProperty;
import org.apache.camel.CamelContext;
import org.apache.camel.model.ProcessorDefinition;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.Expression;
import org.apache.camel.builder.Builder;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseOriginalAggregationStrategy;
import org.apache.camel.spi.Language;

@Action(id = "split", name = "Split", description = "Split your exchange")
public class SplitAction implements Step {

    @ConfigurationProperty(
        name = "language",
        displayName = "Language",
        description = "The language used for the expression")
    private String language;

    @ConfigurationProperty(
        name = "expression",
        displayName = "Expression",
        description = "The expression used to split the exchange")
    private String expression;

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    public String getExpression() {
        return expression;
    }

    public void setExpression(String expression) {
        this.expression = expression;
    }

    @Override
    public Optional<ProcessorDefinition> configure(
            CamelContext context,
            ProcessorDefinition route,
            Map<String, Object> parameters) { // <1>

        String languageName = language;
        String expressionDefinition = expression;

        if (ObjectHelper.isEmpty(languageName) && ObjectHelper.isEmpty(expressionDefinition)) {
            route = route.split(Builder.body());
        } else if (ObjectHelper.isNotEmpty(expressionDefinition)) {

            if (ObjectHelper.isEmpty(languageName)) {
                languageName = "simple";
            }

            final Language splitLanguage = context.resolveLanguage(languageName);
            final Expression splitExpression = splitLanguage.createExpression(expressionDefinition);
            final AggregationStrategy aggreationStrategy = new UseOriginalAggregationStrategy(null, false);

            route = route.split(splitExpression).aggregationStrategy(aggreationStrategy);
        }

        return Optional.of(route);
    }
}
----
<1> the step/action implementation

As we are using java and Syndesis annotations we can leverage the extension-maven-plugin to automatically generate the action definition which will look like:

[source,json]
----
{
  "id": "split",
  "name": "Split",
  "description": "Split your exchange",
  "descriptor": {
    "kind": "STEP", <1>
    "entrypoint": "io.syndesis.extension.split.SplitAction", <2>
    "inputDataShape": {
      "kind": "none"
    },
    "outputDataShape": {
      "kind": "none"
    },
    "propertyDefinitionSteps": [ {
      "description": "extension-properties",
      "name": "extension-properties",
      "properties": {
        "language": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The language used for the expression",
          "displayName": "Language",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        },
        "expression": {
          "componentProperty": false,
          "deprecated": false,
          "description": "The expression used to split the exchange",
          "displayName": "Expression",
          "javaType": "java.lang.String",
          "kind": "parameter",
          "required": false,
          "secret": false,
          "type": "string",
          "raw": false
        }
      }
    } ]
  },
  "tags": [],
  "actionType": "step"
}
----
<1> the type of action is set to `STEP`
<2> the class implementing the `Step` interface
